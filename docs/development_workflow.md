# Minerva 開発ワークフロー

このドキュメントでは、Minervaプロジェクトの開発ワークフローとベストプラクティスについて説明します。

## 1. 開発環境のセットアップ

### 1.1 必要な環境

- Python 3.10以上
- uv（依存関係管理）
- Git

### 1.2 リポジトリのクローンと依存関係のインストール

```bash
# リポジトリのクローン
git clone https://github.com/yourorg/minerva.git
cd minerva

# 依存関係のインストール
uv pip install -e .
```

### 1.3 開発用仮想環境の作成と有効化

```bash
# 新しい仮想環境の作成
uv venv

# 仮想環境の有効化
# Linuxやmacの場合
source .venv/bin/activate
# Windowsの場合
# .venv\Scripts\activate

# 開発用依存関係のインストール
uv pip install -e ".[dev]"
```

### 1.4 .envファイルとPYTHONPATHの設定

本プロジェクトでは、`minerva` モジュールを正しくimportできるようにするため、`.env` ファイルに `PYTHONPATH=src` を追加しています。
これにより、`uv run pytest` などのコマンド実行時に毎回 `PYTHONPATH=src` を指定する必要がありません。

すでに `.env.example` に `PYTHONPATH=src` が記載されているので、`.env` ファイルを作成する際はこの内容をコピーしてください。

## 2. ブランチ戦略

Minervaプロジェクトでは、以下のブランチ戦略を採用しています：

### 2.1 ブランチ種別

- `main`: 安定版のコード、本番環境にデプロイ可能な状態
- `develop`: 開発ブランチ、次のリリース向けの変更を統合
- `feature/<機能名>`: 新機能の開発
- `bugfix/<バグID>`: バグ修正
- `release/<バージョン>`: リリース準備
- `hotfix/<バグID>`: 緊急のバグ修正（本番環境用）

### 2.2 ブランチワークフロー

1. `develop`ブランチから`feature/<機能名>`ブランチを作成
2. 機能開発を実施
3. テストの作成と実行（コードカバレッジの確認）
4. プルリクエストを作成し、コードレビューを依頼
5. レビュー後、`develop`ブランチにマージ
6. リリース準備時に`release/<バージョン>`ブランチを作成
7. リリーステストとドキュメント更新を実施
8. テスト完了後、`main`ブランチと`develop`ブランチにマージ

## 3. 開発サイクル

### 3.1 新機能の開発

新機能を開発する際のワークフローです：

1. 仕様の確認とタスクの分解
2. テスト駆動開発（TDD）の実践：
   - 失敗するテストを作成
   - 最小限のコードで実装
   - テストが通ることを確認
   - リファクタリング
3. AAAパターンに従ったテストの作成・改善
4. ドキュメントの更新
5. コードレビューの依頼

### 3.2 バグ修正

バグを修正する際のワークフローです：

1. バグの再現と問題の特定
2. バグを再現するテストケースの作成
3. バグ修正の実装
4. テストの実行と確認
5. 関連するドキュメントの更新
6. コードレビューの依頼

## 4. コーディング規約

### 4.1 PEP 8

Pythonの公式スタイルガイドであるPEP 8に準拠します。主な規約は以下の通りです：

- インデントは4スペース
- 行の最大長は88文字（Ruff準拠）
- クラス名はCamelCase
- 関数名とメソッド名はsnake_case
- 定数はALL_CAPS
- インポートは標準ライブラリ、サードパーティ、ローカルの順に分類

### 4.2 コードフォーマッタとリンター

Ruffを使用して、コードの品質と一貫性を確保します。Ruffは高速なPythonリンター兼フォーマッタで、以前のBlack、isort、Flake8などの機能を統合したツールです。

全てのPRは、Ruffによるチェックを通過する必要があります。

```bash
# Ruffでのコード形式チェックと問題の表示
uv run ruff check src tests

# Ruffでのコード自動フォーマット（インポート整理を含む）
uv run ruff format src tests

# 型チェックの実行
uv run mypy src tests
```

## 5. コードレビュープロセス

### 5.1 プルリクエスト（PR）の作成

PRには以下の情報を含めてください：

- タイトル：変更内容を簡潔に表現
- 説明：
  - 変更の背景と目的
  - 実装の概要
  - テスト方法
  - 注意点やレビュアーに確認して欲しい点

### 5.2 レビュー基準

コードレビューでは以下の点を確認します：

- 機能要件を満たしているか
- コーディング規約に準拠しているか
- テストが十分かつ適切に書かれているか
- エラー処理が適切か
- パフォーマンスに問題はないか
- セキュリティリスクはないか
- ドキュメントが更新されているか

### 5.3 レビューコメントへの対応

- 全てのコメントに対応する
- 議論が必要な場合はスレッドで続ける
- 対応完了後はレビュアーに再レビューを依頼

## 6. リリースプロセス

### 6.1 バージョニング

セマンティックバージョニング（SemVer）を採用します：

- メジャーバージョン（X.0.0）：後方互換性のない変更
- マイナーバージョン（0.X.0）：後方互換性のある機能追加
- パッチバージョン（0.0.X）：バグ修正

### 6.2 リリース手順

1. `release/<バージョン>`ブランチの作成
2. バージョン番号とCHANGELOGの更新
3. リリーステストの実行
4. ドキュメントの最終確認
5. `main`ブランチへのマージ
6. タグの作成
7. パッケージのビルドと公開（uvを使用）
   ```bash
   # ビルド
   uv pip build

   # 公開
   uv pip publish
   ```
8. `develop`ブランチへのマージ

## 7. ドキュメント管理

### 7.1 ドキュメントの種類

- READMEとセットアップガイド
- 機能仕様書
- 技術仕様書
- テストガイドライン
- APIドキュメント
- ユーザーガイド

### 7.2 ドキュメント更新のタイミング

- 新機能の追加時
- 既存機能の変更時
- 関数シグネチャの変更時
- APIの変更時
- バグ修正による動作変更時
- リリース前の最終確認時

### 7.3 ドキュメント形式

ドキュメントはMarkdown形式で記述し、`docs/`ディレクトリで管理します：

- `docs/note_operations.md` - ノート操作機能仕様書
- `docs/technical_spec.md` - 技術仕様書
- `docs/test_guidelines.md` - テストガイドライン
- `docs/development_workflow.md` - 開発ワークフロー（本ドキュメント）

## 8. 継続的インテグレーションと継続的デリバリー（CI/CD）

### 8.1 CI/CDパイプライン概要

GitHub Actionsを使用して以下のパイプラインを構築しています：

1. **コードの品質チェック**
   - Ruff による構文チェックとコードフォーマット検証
   - MyPy による型チェック
   - プルリクエスト時及びmainブランチ更新時の自動実行

2. **テストの実行**
   - pytest による単体テスト・統合テスト
   - Python 3.12, 3.13 のマトリックステスト
   - カバレッジレポートの生成と Codecov への自動アップロード

   ⚠️ **重要**: テスト失敗時は `docs/test_guidelines.md` の「モジュールキャッシングの問題と対策」セクションを参照してください。特に環境変数を使用するテストでは、モジュールキャッシュクリアが必要な場合があります。

3. **ビルドとリリース**
   - semantic-release による自動バージョニング
   - CHANGELOG の自動生成
   - 将来的な PyPI への自動パッケージ公開

### 8.2 ワークフロー構成

#### 8.2.1 メインCIワークフロー (`.github/workflows/ci.yml`)

**目的**: プルリクエストと main ブランチ更新時の包括的品質チェック

**実行内容**:
- **並列実行ジョブ**:
  - `lint`: Ruff によるコード品質チェック
  - `type-check`: MyPy による型チェック
  - `test`: pytest によるテスト実行（Python マトリックス対応）

**実行時間目標**: 5分以内

#### 8.2.2 プルリクエスト専用チェック (`.github/workflows/pr-checks.yml`)

**目的**: 軽量なクイックチェックによる即座のフィードバック

**実行内容**:
- コミットメッセージ形式チェック（Conventional Commits準拠）
- ドキュメント更新確認
- 基本的なファイル形式チェック

#### 8.2.3 リリースワークフロー (`.github/workflows/release.yml`)

**既存機能**:
- semantic-release による自動バージョニング
- CHANGELOG の自動生成

**CI統合**:
- CI成功後にのみリリースを実行
- `needs: [lint, type-check, test]` 依存関係を設定

### 8.3 自動化されたタスク

#### 8.3.1 コード品質保証

- **Ruff による包括的チェック**:
  ```bash
  # すべてのルールを適用（一部除外）
  uv run ruff check --select ALL --ignore E501,D100,D101,D102,D103,D104,D105
  # フォーマットチェック
  uv run ruff format --check
  ```

- **MyPy による型チェック**:
  ```bash
  uv run mypy src tests
  ```

#### 8.3.2 テスト自動化

- **pytest によるテスト実行**:
  ```bash
  # カバレッジを測定してXMLとHTMLレポートを生成
  uv run pytest --cov=minerva --cov-report=xml --cov-report=html
  ```

- **マトリックステスト**:
  - Python 3.12, 3.13 での並列テスト実行
  - 互換性の確保

#### 8.3.3 カバレッジレポート

- **HTMLレポート生成**: GitHub Actions アーティファクトとして保存
- **Codecov統合**: XML形式レポートの自動アップロード
- **カバレッジ維持**: 現在89%のカバレッジを維持・改善

### 8.4 品質ゲートと保護設定

#### 8.4.1 プルリクエスト保護

- **必須チェック**:
  - すべてのCI ジョブの成功
  - コード品質基準の満足
  - テストカバレッジの維持

- **マージ条件**:
  - CI の成功
  - コードレビューの承認（推奨）

#### 8.4.2 品質基準

- **コード品質**: Ruff による全ルールのチェック
- **型安全性**: MyPy による厳格な型チェック
- **テストカバレッジ**: 最低89%の維持
- **パフォーマンス**: CI実行時間5分以内

### 8.5 段階的実装とロードマップ

#### 8.5.1 Phase 1: 基本ワークフロー（実装済み）

✅ **完了**:
- メインCIワークフロー（`.github/workflows/ci.yml`）
- コード品質チェック（Ruff、MyPy）
- 基本テスト実行とカバレッジ測定

#### 8.5.2 Phase 2: 最適化と拡張（次期実装）

🔄 **実装予定**:
- プルリクエスト専用チェック（`.github/workflows/pr-checks.yml`）
- Python マトリックステスト（3.12、3.13）
- Codecov統合

#### 8.5.3 Phase 3: 高度な機能（将来実装）

📋 **計画**:
- セキュリティチェック（依存関係の脆弱性スキャン）
- PyPI への自動パッケージ公開
- パフォーマンステストの自動化

### 8.6 モニタリングと改善

#### 8.6.1 メトリクス監視

- **実行時間**: CI パイプラインの実行時間を監視
- **成功率**: テスト成功率とCI成功率の追跡
- **カバレッジ**: コードカバレッジの推移を監視

#### 8.6.2 継続的改善

- **定期的レビュー**: CI設定の見直し（月次）
- **パフォーマンス最適化**: 実行時間短縮の施策
- **新技術導入**: GitHub Actions の新機能活用

## 9. 問題解決とサポート

### 9.1 問題報告

バグや改善要望は、以下の情報を含めてIssueとして登録してください：

- 問題の概要
- 再現手順
- 期待される動作
- 実際の動作
- 環境情報（OSやPythonのバージョンなど）
- スクリーンショットや参考情報（可能であれば）

### 9.2 サポートチャンネル

- GitHub Issues：バグ報告と機能リクエスト
- Slack：チーム内のコミュニケーション
- ドキュメント：自己解決のための情報源

## 10. 開発のベストプラクティス

- シンプルで読みやすいコードを書く
- 適切な抽象化レベルを保つ
- DRY原則（Don't Repeat Yourself）を守る
- SOLID原則に従う
- 小さくて焦点を絞ったPRを作成する
- テスト駆動開発を実践する
- **ドキュメント・ファースト**アプローチを実践する（コードよりもドキュメントを先に更新する）
- 定期的にコードレビューを行う

### 10.1 ドキュメント・ファーストアプローチ

Minervaプロジェクトでは、コードを実装する前に関連するドキュメントを先に更新する「ドキュメント・ファースト」アプローチを採用しています。

#### 10.1.1 ドキュメント・ファーストの利点

- 事前の設計思考が促進され、実装の質が向上する
- チーム全体での機能理解が統一される
- コードレビューが効率化される
- ドキュメントの鮮度が保たれる
- 新しいプロジェクトメンバーの教育コストが削減される
- 実装前に潜在的な問題を早期発見できる

#### 10.1.2 ドキュメント更新の手順

1. **要件ドキュメントの更新**（`docs/requirements.md`）
   - 機能の要件定義
   - 入出力の仕様
   - エラー条件とエッジケース

2. **技術仕様書の更新**（`docs/technical_spec.md`）
   - クラス・関数のシグネチャ
   - 処理フローの定義
   - データモデルの定義
   - エラーハンドリング方針

3. **その他関連ドキュメントの更新**
   - `README.md`（必要に応じて）
   - 機能仕様書（`docs/note_operations.md`など）
   - テストガイドライン（`docs/test_guidelines.md`）

4. **コード実装**
   - ドキュメントに基づいた実装
   - テストコードの作成
   - 実装とドキュメントの整合性確認

#### 10.1.3 AIアシスタントとの連携

GitHub Copilotなどのコードアシスタントを使用する場合も、ドキュメント・ファーストアプローチを徹底してください。`.github/instructions/patterns/document_first.md`の指示に従って、AIにドキュメント更新を優先させるようガイドします。

### 10.1 依存関係管理のベストプラクティス

#### 10.1.1 開発環境と実行環境の分離理解

Minervaプロジェクトでは、2つの環境で依存関係を管理する必要があります：

1. **プロジェクトの開発環境**：
   - `pyproject.toml`と`uv.lock`で管理される環境
   - 開発、テスト実行、CI/CD環境で使用される

2. **Claude Desktop実行環境**：
   - `claude_desktop_config.json`の`--with`オプションで指定される一時的な環境
   - サーバー実行時のみ使用され、実行後に破棄される

#### 10.1.2 依存関係変更時のチェックリスト

新しい依存関係を追加する際のチェックリストです：

1. `pyproject.toml`の`dependencies`に依存関係を追加
2. `uv pip install -e .`を実行して開発環境に反映
3. `uv.lock`が更新されていることを確認
4. コードで正しいインポート名を使用していることを確認
5. Claude Desktop設定ファイルの`--with`オプションにも同じパッケージを追加
6. VSCode/Claude Desktopを再起動してサーバーが正常に起動することを確認

#### 10.1.3 パッケージ名とインポート名の違いに注意

パッケージによっては、インストール時の名前（PyPIパッケージ名）とPythonでインポートする際の名前が異なる場合があります：

| インストール名 (PyPI) | インポート名 (Python) | 例 |
|-----------------|----------------|-----------|
| python-frontmatter | frontmatter | `import frontmatter` |
| python-dotenv | dotenv | `import dotenv` |

このような違いがある場合は、両方のドキュメントで明確に記述しましょう。

これらのガイドラインに従うことで、Minervaプロジェクトの開発効率と品質を高めていきましょう。
